<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态爱心汇聚效果 (升级版)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <canvas id="heartCanvas"></canvas>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        // --- 可配置区域 ---
        const texts = [
            { content: "爱你 ♥", x: 0.5, y: 0.3, size: 28, color: "pink" },
            { content: "♥ To my love ♥", x: 0.5, y: 0.5, size: 20, color: "rgba(255, 182, 193, 0.8)" },
            { content: "♥", x: 0.25, y: 0.6, size: 22, color: "pink" },
            { content: "Forever", x: 0.75, y: 0.7, size: 22, color: "pink" }
        ];
        // --- 可配置区域结束 ---

        let particles = [];
        let heartShape = [];
        let animationFrameId;

        function getHeartPoint(t) {
            const scale = Math.min(width, height) * 0.035;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            return {
                x: x * scale + width / 2,
                y: y * scale + height / 2
            };
        }

        function createHeartShape() {
            heartShape = [];
            for (let t = 0; t < Math.PI * 2; t += 0.02) {
                heartShape.push(getHeartPoint(t));
            }
        }

        class Particle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.target = heartShape[Math.floor(Math.random() * heartShape.length)];
                this.size = Math.random() * 3 + 1;
                this.speed = Math.random() * 0.03 + 0.01;
                this.color = `hsl(${330 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`;
            }

            update(pulse) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                
                this.x += dx * this.speed;
                this.y += dy * this.speed;

                const distToCenter = Math.sqrt(Math.pow(this.x - width / 2, 2) + Math.pow(this.y - height / 2, 2));
                
                this.draw(pulse, distToCenter);
            }

            draw(pulse, distToCenter) {
                ctx.beginPath();
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.7;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                const size = this.size * (1 + pulse * (distToCenter / 200));
                ctx.font = `${size}px Arial`;
                ctx.fillText('♥', this.x, this.y);
                ctx.closePath();
            }
        }

        // ==========================================================
        // ===== 新增：绘制巨大朦胧的背景爱心函数 =====
        // ==========================================================
        function drawBigHeart() {
            const scale = Math.min(width, height) * 0.13;
            const centerX = width / 2;
            const centerY = height / 2;

            ctx.beginPath();
            for (let t = 0; t < Math.PI * 2; t += 0.01) {
                const x_base = 16 * Math.pow(Math.sin(t), 3);
                const y_base = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                const x = x_base * scale + centerX;
                const y = y_base * scale + centerY;
                if (t === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, scale * 2);
            gradient.addColorStop(0, 'rgba(255, 100, 150, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 20, 147, 0.05)');

            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(255, 105, 180, 0.7)';
            ctx.shadowBlur = 80 + Math.sin(Date.now() * 0.002) * 15;

            // Missing fill() call to actually draw the heart
            ctx.fill();
        }

        // ==============================================
        // ===== 缺失的核心动画逻辑 - START =====
        // ==============================================

        function drawText() {
            ctx.shadowBlur = 0; // Reset shadow for text
            ctx.globalAlpha = 1.0;
            texts.forEach(text => {
                ctx.fillStyle = text.color;
                ctx.font = `bold ${text.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text.content, width * text.x, height * text.y);
            });
        }

        function init() {
            particles = [];
            createHeartShape();
            for (let i = 0; i < 500; i++) { // Create 500 particles
                particles.push(new Particle());
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height); // Clear canvas each frame
            
            drawBigHeart(); // Call the function to draw the background heart

            const pulse = Math.sin(Date.now() * 0.005) * 0.2;

            particles.forEach(p => {
                p.update(pulse);
            });
            
            drawText(); // Draw the configured text

            animationFrameId = requestAnimationFrame(animate);
        }

        function onResize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            cancelAnimationFrame(animationFrameId); // Stop the old animation
            init(); // Re-initialize with new dimensions
            animate(); // Start the new animation
        }

        window.addEventListener('resize', onResize);

        // Start everything
        init();
        animate();
        
        // ==============================================
        // ===== 缺失的核心动画逻辑 - END =====
        // ==============================================
    </script>
</body>
</html>